// Test framework dependencies
import test from 'ava'

// Test helpers
import { DBError } from 'objection'
import EventModel from '../../app/model/water/event.model.js'

// Thing under test
import LegacyBaseModel from '../../app/model/legacy-base.model.js'

test('.schema > When the getter is not overridden it throws an error', (t) => {
  t.throws(() => NoSchemaModel.query(),
    {
      instanceOf: Error,
      message: 'defaultSchema() not implemented in child class'
    }
  )
})

test('.schema > When the getter is overridden it does not throw an error', (t) => {
  t.notThrows(() => GoodModel.query())
})

test('.translations > When the getter is not overridden it throws an error', (t) => {
  const instance = new NoTranslationsModel()

  t.throws(() => instance.$parseDatabaseJson(),
    {
      instanceOf: Error,
      message: 'translations() not implemented in child class'
    }
  )
})

test('.translations > When the getter is overridden it does not throw an error', (t) => {
  const instance = new GoodModel()

  t.notThrows(() => instance.$parseDatabaseJson())
})

test('When working with models that use translations, when coming from the database any column names listed that ' +
  'match are translated in the model properties', (t) => {
  const yeOldeBilling = new YeOldeBillingModel()

  // You would never call this directly. $parseDatabaseJson() is an objection method we're overloading in
  // LegacyBaseModel. But it gives us the JSON Objection.js will then use to build the model so it works for this test.
  // The JSON it expects as a param is generated by Objection based on the table in the DB. Note: The spread operator is
  // used to create a shallow clone as $parseDatabaseJson() amends the value passed in. That would break subsequent
  // tests
  const result = yeOldeBilling.$parseDatabaseJson({
    billingId: '76353750-5ace-411a-b00c-4e4a9ac934fb',
    yehAlrightLove: 'Hello'
  })

  t.deepEqual(
    result,
    { billingId: '76353750-5ace-411a-b00c-4e4a9ac934fb', greeting: 'Hello' }
  )
})

test('When working with models that use translations, when coming from the database any column names listed that ' +
  'do not match are ignored in the model properties', (t) => {
  const yeOldeBilling = new YeOldeBillingModel()

  const result = yeOldeBilling.$parseDatabaseJson({
    billingId: '76353750-5ace-411a-b00c-4e4a9ac934fb',
    yehAlrightLove: 'Hello'
  })

  t.is(result.noMatchPropertyName, undefined)
})

test('When working with models that use translations, when coming from the model any property names listed that ' +
  'match are translated in the column names', (t) => {
  const yeOldeBilling = new YeOldeBillingModel()

  // You would never call this directly. $formatDatabaseJson() is an objection method we're overloading in
  // LegacyBaseModel. But it gives us the JSON Objection.js will then use to build to build the query so it works for
  // this test. The JSON it expects as a param is generated by Objection based on the model instance. Note: The spread
  // operator is used to create a shallow clone as $formatDatabaseJson() amends the value passed in. That would break
  // subsequent tests
  const result = yeOldeBilling.$formatDatabaseJson({
    billingId: '76353750-5ace-411a-b00c-4e4a9ac934fb',
    greeting: 'Hello'
  })

  t.deepEqual(
    result,
    { billingId: '76353750-5ace-411a-b00c-4e4a9ac934fb', yehAlrightLove: 'Hello' }
  )
})

test('When working with models that use translations, when coming from the model any property names listed that ' +
  'do not match are ignored in the column names', (t) => {
  const yeOldeBilling = new YeOldeBillingModel()

  const result = yeOldeBilling.$formatDatabaseJson({
    billingId: '76353750-5ace-411a-b00c-4e4a9ac934fb',
    greeting: 'Hello'
  })

  t.is(result.noMatchColumnName, undefined)
})

test('When working with models that use translations they throw an error if the model property name is used in a ' +
  'query', async (t) => {
  const timeNow = new Date().toISOString()

  await t.throwsAsync(EventModel.query().where('createdAt', '<', timeNow),
    {
      instanceOf: DBError
    }
  )
})

class GoodModel extends LegacyBaseModel {
  static get schema () {
    return 'water'
  }

  static get translations () {
    return []
  }
}

class NoSchemaModel extends LegacyBaseModel {
  static get translations () {
    return []
  }
}

class NoTranslationsModel extends LegacyBaseModel {
  static get schema () {
    return 'water'
  }
}

class YeOldeBillingModel extends LegacyBaseModel {
  static get translations () {
    return [
      { database: 'yehAlrightLove', model: 'greeting' },
      { database: 'noMatchColumnName', model: 'noMatchPropertyName' }
    ]
  }
}
